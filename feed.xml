<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Cascade Of Insights</title>
    <link href="/feed.xml" rel="self" />
    <link href="" />
    <id>/feed.xml</id>
    <author>
        <name>Adam Bell</name>
        <email>agbell at gmail.com</email>
    </author>
    <updated>2016-06-22T00:00:00Z</updated>
    <entry>
    <title>Scalaz для ежедневного использования. Часть 3: Монада State, монада Writer и линзы.</title>
    <link href="/posts/2016-06-22-scalaz-features-for-everyday-usage-part-3.html" />
    <id>/posts/2016-06-22-scalaz-features-for-everyday-usage-part-3.html</id>
    <published>2016-06-22T00:00:00Z</published>
    <updated>2016-06-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="blog-post">
  <h2 class="blog-post-title">
    Scalaz для ежедневного использования. Часть 3: Монада State, монада Writer и линзы.
  </h2>
  <p class="blog-post-meta">
    <span class="date">2016-06-22</span> - <span class="tags"><a href="/tags/scala.html">scala</a>, <a href="/tags/scalaz%20%D0%B4%D0%BB%D1%8F%20%D0%B5%D0%B6%D0%B5%D0%B4%D0%BD%D0%B5%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.html">scalaz для ежедневного использования</a>, <a href="/tags/scalaz.html">scalaz</a>, <a href="/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4.html">перевод</a></span>
  <p>В этой статье мы посмотрим на пару монад и паттернов из Scalaz. Напомню, что мы будем смотреть на них с практической точки зрения и избегать внутренних деталей Scalaz. В данной статье мы рассмотрим:</p>
<!--more-->
<ul>
<li>Монада Writer: Ведёт своего рода логи во время выполнения набора операций.</li>
<li>Монада State: Предоставляет простой способ пробрасывания состояния между функциями.</li>
<li>Линзы: Предоставляет простой доступ к глубоко вложенным атрибутам и делает создание копий иерархии case class’ов более удобным.</li>
</ul>
<h3 id="монада-writer">Монада Writer</h3>
<p>В своей основе каждый Writer имеет журнал и возвращаемое значение. Например, вы можете просто написать чистый код, а потом уже решить что вы хотите делать с логами(проверить их в тесте, вывести в консоль или в файл). Таким образом, мы можем использовать Writer для того, чтобы следить за операциями которые мы выполняем.</p>
<p><em>Примечание от переводчика: монаду Writer можно использовать не только для логирования, но я буду придерживаться текста оригинальной статьи, а более подробно расскажу об этом в другой статье.</em></p>
<p>Итак, давайте посмотрим на следующий код для того, чтобы понять как это работает:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> scalaz.<span class="fu">_</span>
<span class="kw">import</span> Scalaz.<span class="fu">_</span>

<span class="kw">object</span> WriterSample <span class="kw">extends</span> App {

  <span class="co">// левая часть должна быть моноидом. Другими словами это нечто поддерживающее</span>
  <span class="co">// &quot;конкатенацию&quot; и имеющее нейтральный элемент, например, String, List, Set и т.д.</span>
  <span class="kw">type</span> Result[T] = Writer[List[String], T]

  <span class="kw">def</span> <span class="fu">doSomeAction</span>() : Result[Int] = {
    <span class="co">// провести вычисления для получения результата</span>
    <span class="kw">val</span> res = <span class="dv">10</span>
    <span class="co">// создать writer используя set</span>
    res.<span class="fu">set</span>(List(s<span class="st">&quot;Doing some action and returning res&quot;</span>))
  }

  <span class="kw">def</span> <span class="fu">doingAnotherAction</span>(b: Int) : Result[Int] = {
    <span class="co">// провести вычисления для получения результата</span>
    <span class="kw">val</span> res = b * <span class="dv">2</span>
    <span class="co">// создать writer используя set</span>
    res.<span class="fu">set</span>(List(s<span class="st">&quot;Doing another action and multiplying $b with 2&quot;</span>))
  }

  <span class="kw">def</span> <span class="fu">andTheFinalAction</span>(b: Int) : Result[String] = {
    <span class="kw">val</span> res = s<span class="st">&quot;bb:$b:bb&quot;</span>

    <span class="co">// создать writer используя set</span>
    res.<span class="fu">set</span>(List(s<span class="st">&quot;Final action is setting $b to a string&quot;</span>))
  }

  <span class="co">// возвращает кортеж: (List, Int)</span>
  <span class="fu">println</span>(<span class="fu">doSomeAction</span>().<span class="fu">run</span>)

  <span class="kw">val</span> combined = <span class="kw">for</span> {
    a &lt;- <span class="fu">doSomeAction</span>()
    b &lt;- <span class="fu">doingAnotherAction</span>(a)
    c &lt;- <span class="fu">andTheFinalAction</span>(b)
  } <span class="kw">yield</span> c

  <span class="co">// возвращает кортеж: (List, String)</span>
  <span class="fu">println</span>(combined.<span class="fu">run</span>)
}</code></pre></div>
<p>В данном примере у нас есть три операции которые делают что-то. В данном случае, они на самом деле почти ничего не делают, но нам это и не важно. Основая идея в том, что мы вместо результата возвращаем Writer(заметим, что мы так же могли бы создать Writer внутри for-генератора) с помощью функции <code>set</code>. Когда мы вызываем <code>run</code> у Writer, мы получаем не только результат, но и агрегированные значения которые он собрал. Поэтому, когда мы делаем:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Result[T] = Writer[List[String], T]

<span class="kw">def</span> <span class="fu">doSomeAction</span>() : Result[Int] = {
  <span class="co">// провести вычисления для получения результата</span>
  <span class="kw">val</span> res = <span class="dv">10</span>
  <span class="co">// создать writer используя set</span>
  res.<span class="fu">set</span>(List(s<span class="st">&quot;Doing some action and returning res&quot;</span>))
}

<span class="fu">println</span>(<span class="fu">doSomeAction</span>().<span class="fu">run</span>)</code></pre></div>
<p>Результат будет выглядеть как <code>(List(Doing some action and returning res),10)</code>. Не то чтобы это очень захватывающе, но мы можем делать более интересные вещи используя writer в for-генераторе.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> combined = <span class="kw">for</span> {
  a &lt;- <span class="fu">doSomeAction</span>()
  b &lt;- <span class="fu">doingAnotherAction</span>(a)
  c &lt;- <span class="fu">andTheFinalAction</span>(b)
} <span class="kw">yield</span> c

<span class="co">// возвращаем кортеж: (List, String)</span>
<span class="fu">println</span>(combined.<span class="fu">run</span>)</code></pre></div>
<p>Данный код выведет в консоль:</p>
<pre><code>(List(Doing some action and returning res,
     Doing another action and multiplying 10 with 2,
     Final action is setting 20 to a string)
 ,bb:20:bb)</code></pre>
<p>Как вы можете видеть, мы собрали все логи в <code>List[String]</code> и полученный кортеж так же содержит результат вычислений.</p>
<p>Если вы не хотите добавлять создание writer’ов в ваши функции вы можете создать их в for-генераторе:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> combined2 = <span class="kw">for</span> {
   a &lt;- <span class="fu">doSomeAction1</span>()     <span class="fu">set</span>(<span class="st">&quot; Executing Action 1 &quot;</span>)   <span class="co">// String тоже моноид</span>
   b &lt;- <span class="fu">doSomeAction2</span>(a)    <span class="fu">set</span>(<span class="st">&quot; Executing Action 2 &quot;</span>)
   c &lt;- <span class="fu">doSomeAction2</span>(b)    <span class="fu">set</span>(<span class="st">&quot; Executing Action 3 &quot;</span>)
<span class="co">//  c &lt;- WriterT.writer(&quot;bla&quot;, doSomeAction2(b))   // альтернативный вариант создания</span>
 } <span class="kw">yield</span> c

 <span class="fu">println</span>(combined2.<span class="fu">run</span>)</code></pre></div>
<p>В результате мы получим:</p>
<pre><code>( Executing Action 1  Executing Action 2  Executing Action 3 ,5)</code></pre>
<h3 id="монада-state">Монада State</h3>
<p>Другая интересная монада это монада State, она позволяет работать с состоянием которое должно быть передано через несколько функций. С помощью неё вы можете отслеживать результаты или передавать некоторый контекст между функциями. В предыдущей статье вы уже видели как можно передать некоторый контест в функцию с помощью монады Reader, однако, этот контест нельзя было изменять. Монада State предоставляет удобный способ безопасной и чистой передачи изменяемого контекста.</p>
<p>Давайте посмотрим на следующий пример:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">LeftOver</span>(size: Int)

<span class="co">/** State представляет из себя функцию `S =&gt; (S, A)`. */</span>
<span class="kw">type</span> Result[A] = State[LeftOver, A]

<span class="kw">def</span> <span class="fu">getFromState</span>(a: Int): Result[Int] = {
  <span class="co">// делаем любые виды вычислений</span>
  State[LeftOver, Int] {
    <span class="co">// просто возвращаем количество денег которое мы взяли</span>
    <span class="co">// и новый State</span>
    <span class="kw">case</span> x =&gt; (<span class="fu">LeftOver</span>(x.<span class="fu">size</span> - a), a)
  }
}

<span class="kw">def</span> <span class="fu">addToState</span>(a: Int): Result[Int] = {
  <span class="co">// делаем любые виды вычислений</span>
  State[LeftOver, Int] {
    <span class="co">// просто возвращаем сумму которую мы добавили</span>
    <span class="co">// и новый State</span>
    <span class="kw">case</span> x =&gt; (<span class="fu">LeftOver</span>(x.<span class="fu">size</span> + a), a)
  }
}

<span class="kw">val</span> res: Result[Int] = <span class="kw">for</span> {
  _ &lt;-  <span class="fu">addToState</span>(<span class="dv">20</span>)
  _ &lt;- <span class="fu">getFromState</span>(<span class="dv">5</span>)
  _ &lt;- <span class="fu">getFromState</span>(<span class="dv">5</span>)
  a &lt;- <span class="fu">getFromState</span>(<span class="dv">5</span>)
  currentState &lt;- get[LeftOver]                <span class="co">// получаем состояние в данный момент</span>
  manualState &lt;- put[LeftOver](<span class="fu">LeftOver</span>(<span class="dv">9000</span>)) <span class="co">// задаём новое состояние</span>
  b &lt;- <span class="fu">getFromState</span>(<span class="dv">10</span>) <span class="co">// и продолжаем работать с новым State</span>
} <span class="kw">yield</span> {
  <span class="fu">println</span>(s<span class="st">&quot;currenState: $currentState&quot;</span>)
  a
}

<span class="co">// мы начинаем с состояния 10, и после всех операций мы остаёмся с 5</span>
<span class="co">// без необходимости пробрасывать состояние с помощью implicits</span>
<span class="co">// или чего-нибудь ещё</span>
<span class="fu">println</span>(<span class="fu">res</span>(<span class="fu">LeftOver</span>(<span class="dv">10</span>)))</code></pre></div>
<p>Как вы видите в каждой функции мы получаем текущий контекст, проделываем над ним какие-нибудь операции и возвращаем кортеж содержащий новый State и значение функции. Таким образом, каждая функция имеет доступ к состоянию, может вернуть новое состояние и возвращает его вместе со значением функции как кортеж. Когда мы запускаем данный код мы получаем:</p>
<pre><code>currenState: LeftOver(15)
(LeftOver(8990),5)</code></pre>
<p>В итоге, каждая функция делает что-то с состоянием. С помощью функции <code>get</code> мы можем получить значение в текущий момент времени и в данном примере мы это печатаем в консоль. Кроме того, мы можем непосредственно задать состояние с помощью функции <code>set</code>.</p>
<p>Как вы можете видеть это очень хороший и простой для использования паттерн, позволяющий пробрасывать состояние между функциями.</p>
<h3 id="линзы">Линзы</h3>
<p>Давайте пока оставим монады и посмотрим на линзы. С помощью линз можно просто(ну проще чем просто копировать case class’ы руками) изменять значения в иерархии вложенных объектов. Линзы позволяют сделать очень многое, но в этой статье мы остановимся на нескольких основных вещах. Давайте посмотрим на код:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> scalaz.<span class="fu">_</span>
<span class="kw">import</span> Scalaz.<span class="fu">_</span>

<span class="kw">object</span> LensesSample <span class="kw">extends</span> App {

  <span class="co">// паршивая case модель с отсутствием креатива</span>
  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Account</span>(userName: String, person: Person)
  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(firstName: String, lastName: String, address: List[Address], gender: Gender)
  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Gender</span>(gender: String)
  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Address</span>(street: String, number: Int, postalCode: PostalCode)
  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">PostalCode</span>(numberPart: Int, textPart: String)

  <span class="kw">val</span> acc1 = <span class="fu">Account</span>(<span class="st">&quot;user123&quot;</span>, <span class="fu">Person</span>(<span class="st">&quot;Jos&quot;</span>, <span class="st">&quot;Dirksen&quot;</span>,
                List(<span class="fu">Address</span>(<span class="st">&quot;Street&quot;</span>, <span class="dv">1</span>, <span class="fu">PostalCode</span>(<span class="dv">12</span>,<span class="st">&quot;ABC&quot;</span>)),
                     <span class="fu">Address</span>(<span class="st">&quot;Another&quot;</span>, <span class="dv">2</span>, <span class="fu">PostalCode</span>(<span class="dv">21</span>,<span class="st">&quot;CDE&quot;</span>))),
                <span class="fu">Gender</span>(<span class="st">&quot;male&quot;</span>)))


  <span class="kw">val</span> acc2 = <span class="fu">Account</span>(<span class="st">&quot;user345&quot;</span>, <span class="fu">Person</span>(<span class="st">&quot;Brigitte&quot;</span>, <span class="st">&quot;Rampelt&quot;</span>,
                List(<span class="fu">Address</span>(<span class="st">&quot;Blaat&quot;</span>, <span class="dv">31</span>, <span class="fu">PostalCode</span>(<span class="dv">67</span>,<span class="st">&quot;DEF&quot;</span>)),
                     <span class="fu">Address</span>(<span class="st">&quot;Foo&quot;</span>, <span class="dv">12</span>, <span class="fu">PostalCode</span>(<span class="dv">45</span>,<span class="st">&quot;GHI&quot;</span>))),
                <span class="fu">Gender</span>(<span class="st">&quot;female&quot;</span>)))


  <span class="co">// Если теперь вы хотите изменить что-то, скажем, изменить пол (просто потому, что можем) нам нужно начать копировать всё подряд  </span>
  <span class="kw">val</span> acc1Copy = acc1.<span class="fu">copy</span>(
    person = acc1.<span class="fu">person</span>.<span class="fu">copy</span>(
      gender = <span class="fu">Gender</span>(<span class="st">&quot;something&quot;</span>)
    )
  )</code></pre></div>
<p>В данном примере мы определили несколько case class’ов и хотим изменить одно значение. Для case class’ов это означает, что мы должны скопировать всю иерархию объектов для изменения вложенных значений. Для простых случаев это выглядит не сложно, но используя такой подход код довольно быстро становится громоздким. С линзами мы можем получить механизм для того чтобы сделать это в более композитном стиле:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> genderLens = Lens.<span class="fu">lensu</span>[Account, Gender](
   (account, gender) =&gt; account.<span class="fu">copy</span>(person = account.<span class="fu">person</span>.<span class="fu">copy</span>(gender = gender)),
   (account) =&gt; account.<span class="fu">person</span>.<span class="fu">gender</span>
 )

 <span class="co">// и используя линзы мы можем непосредственно изменить пол</span>
 <span class="kw">val</span> updated = genderLens.<span class="fu">set</span>(acc1, <span class="fu">Gender</span>(<span class="st">&quot;Blaat&quot;</span>))
 <span class="fu">println</span>(updated)

#Вывод: <span class="fu">Account</span>(user123,<span class="fu">Person</span>(Jos,Dirksen,List(<span class="fu">Address</span>(Street,<span class="dv">1</span>,<span class="fu">PostalCode</span>(<span class="dv">12</span>,ABC)),
         <span class="fu">Address</span>(Another,<span class="dv">2</span>,<span class="fu">PostalCode</span>(<span class="dv">21</span>,CDE))),<span class="fu">Gender</span>(Blaat)))</code></pre></div>
<p>Таким образом мы определили линзу, которая может изменить конкретное значение в иерархии. С помощью этой линзы мы можем напрямую обратиться и установить новое значение во вложенной иерархии. Мы так же можем создать линзу которая изменяет значение и возвращает модифицированный объект с помощью оператора <code>=&gt;=</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// мы можем использовать базовую линзу для создания модифицирующей линзы</span>
<span class="kw">val</span> toBlaBlaLens = genderLens =&gt;= (_ =&gt; <span class="fu">Gender</span>(<span class="st">&quot;blabla&quot;</span>))
<span class="fu">println</span>(<span class="fu">toBlaBlaLens</span>(acc1))
#Вывод:  <span class="fu">Account</span>(user123,<span class="fu">Person</span>(Jos,Dirksen,List(<span class="fu">Address</span>(Street,<span class="dv">1</span>,<span class="fu">PostalCode</span>(<span class="dv">12</span>,ABC)),
          <span class="fu">Address</span>(Another,<span class="dv">2</span>,<span class="fu">PostalCode</span>(<span class="dv">21</span>,CDE))),<span class="fu">Gender</span>(blabla)))

<span class="kw">val</span> existingGender = genderLens.<span class="fu">get</span>(acc1)
<span class="fu">println</span>(existingGender)
#Вывод: <span class="fu">Gender</span>(male)</code></pre></div>
<p>И мы можем использовать операторы <code>&gt;=&gt;</code> и <code>&lt;=&lt;</code> для того, чтобы скомбинировать линзы. Например, в следующем примере мы создаём отдельные линзы, которые потом комбинируются и выполняются:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// для начала создадим линзу возвращающую &quot;человека&quot;</span>
<span class="kw">val</span> personLens = Lens.<span class="fu">lensu</span>[Account, Person](
  (account, person) =&gt; account.<span class="fu">copy</span>(person = person),
  (account) =&gt; account.<span class="fu">person</span>
)

<span class="co">// получаем фамилию</span>
<span class="kw">val</span> lastNameLens = Lens.<span class="fu">lensu</span>[Person, String](
  (person, lastName) =&gt; person.<span class="fu">copy</span>(lastName = lastName),
  (person) =&gt; person.<span class="fu">lastName</span>
)


<span class="co">// получаем человека, потом берём фамилию и задаём новую фамилию</span>
<span class="kw">val</span> combined = (personLens &gt;=&gt; lastNameLens) =&gt;= (_ =&gt; <span class="st">&quot;New LastName&quot;</span>)

<span class="fu">println</span>(<span class="fu">combined</span>(acc1))

#Вывод: <span class="fu">Account</span>(user123,<span class="fu">Person</span>(Jos,New LastName,List(<span class="fu">Address</span>(Street,<span class="dv">1</span>,<span class="fu">PostalCode</span>(<span class="dv">12</span>,ABC)),
          <span class="fu">Address</span>(Another,<span class="dv">2</span>,<span class="fu">PostalCode</span>(<span class="dv">21</span>,CDE))),<span class="fu">Gender</span>(male)))</code></pre></div>
<h3 id="заключение">Заключение</h3>
<p>Есть ещё две темы о которых я хочу написать, это Validations и свободные монады. В следующей статье я покажу как можно использовать ValidationNEL. Однако, я думаю, что свободные монады не попадают в категорию вещей для ежедневного использовая, поэтому, возможно, я напишу о них в других статьях в будущем.</p>

  <div id="socialButtons">
    <script type="text/javascript" src="//yastatic.net/es5-shims/0.0.2/es5-shims.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="//yastatic.net/share2/share.js" charset="utf-8"></script>
    <div class="ya-share2" data-services="vkontakte,facebook,linkedin,gplus,twitter,blogger,reddit,evernote,lj,pocket" data-counter=""></div>
  </div>

  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'beizeroblog'; // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
]]></summary>
</entry>
<entry>
    <title>Scalaz для ежедневного использования. Часть 2: Монадные трансформеры и монада Reader.</title>
    <link href="/posts/2016-06-17-scalaz-features-for-everyday-usage-part-2.html" />
    <id>/posts/2016-06-17-scalaz-features-for-everyday-usage-part-2.html</id>
    <published>2016-06-17T00:00:00Z</published>
    <updated>2016-06-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="blog-post">
  <h2 class="blog-post-title">
    Scalaz для ежедневного использования. Часть 2: Монадные трансформеры и монада Reader.
  </h2>
  <p class="blog-post-meta">
    <span class="date">2016-06-17</span> - <span class="tags"><a href="/tags/scala.html">scala</a>, <a href="/tags/scalaz%20%D0%B4%D0%BB%D1%8F%20%D0%B5%D0%B6%D0%B5%D0%B4%D0%BD%D0%B5%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.html">scalaz для ежедневного использования</a>, <a href="/tags/scalaz.html">scalaz</a>, <a href="/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4.html">перевод</a></span>
  <p>Во второй статье “Scalaz для ежедневного использования” мы рассмотрим монадные трансформеры и монаду Reader. Начнём с монадных трансформеров. Они пригодятся когда вам нужно иметь дело с вложенными монадами, что происходит удивительно часто. Например, когда вам нужно работать с вложенными Future[Option] или Future[Either], ваши for-генераторы довольно быстро могут стать не читаемыми, так как вам нужно обрабатывать None и Some для Option, а так же Success и Failure для Future явно.</p>
<!--more-->
<h3 id="работаем-без-монадных-трансформеров">Работаем без монадных трансформеров</h3>
<p>Как мы уже говорили во введении монадные трансформеры полезны при работе с вложенными монадами. Когда вы можете с ними столкнуться? Например, библиотеки для работы с базами данных обычно ассинхронные(используют Future) и в некоторых случаях возвращают Option. Предположим, вы запрашиваете специальную запись которая возвращает Future[Option[T]]:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"># Phantom драйвер для <span class="fu">cassandra</span> (без implicits) возвращает Some(Record) если запись найдена
# или None иначе
<span class="kw">def</span> <span class="fu">one</span>(): Future[Option[Record]]

# или вы можете захотеть получить первый элемент из запроса Slick
<span class="kw">val</span> res : Future[Option[Row]] = db.<span class="fu">run</span>(<span class="fu">filterQuery</span>(id).<span class="fu">result</span>.<span class="fu">headOption</span>)</code></pre></div>
<p>Или вы можете просто иметь свой сервис, определяющий функции, которые возвращают Either или Option как результат:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"># возвращает аккаунт или None если аккаунт не найден
<span class="kw">def</span> <span class="fu">getAccount</span>() : Future[Option[Account]]

# снимает сумму со счёта, возвращает новую сумму на счёте
# или сообщение объясняющее что пошло не так
<span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount) : Future[\/[String, Amount]]</code></pre></div>
<p>Давайте рассмотрим пример некрасивого кода который может получиться если не использовать монадные трансформеры:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"> <span class="kw">def</span> <span class="fu">withdrawWithoutMonadTransformers</span>(accountNumber: String, amount: Amount) : Future[Option[Statement]] = {
  <span class="kw">for</span> {
    <span class="co">// возвращает Future[Option[Account]]</span>
    account &lt;- Accounts.<span class="fu">getAccount</span>(accountNumber)
    <span class="co">// мы можем сделать свёртку, используя функцию из scalaz для получения &quot;нетипизированного&quot; None</span>
    balance &lt;- account.<span class="fu">fold</span>(Future(none[Amount]))(Accounts.<span class="fu">getBalance</span>(_))
    <span class="co">// или иногда нам нужно использовать сопоставление с образцом</span>
    _ &lt;- (account, balance) <span class="kw">match</span> {
      <span class="kw">case</span> (Some(acc), Some(bal)) =&gt; Future(Accounts.<span class="fu">withdraw</span>(acc,bal))
      <span class="kw">case</span> _ =&gt; Future(None)
    }
    <span class="co">// или мы можем сделать вложенный map</span>
    statement &lt;- Future(account.<span class="fu">map</span>(Accounts.<span class="fu">getStatement</span>(_)))
  } <span class="kw">yield</span> statement
}</code></pre></div>
<p>Как мы видим, когда нам нужно работать с вложенными монадами, приходится обрабатывать внутренние монады пошагово в правой части for-генератора. Scala очень богатый язык, поэтому у нас есть много способов сделать это, но код не получается более читаемым. Мы вынуждены прибегать к вложенным map и flatmap, использовать fold(в случае Option) или прибегать к помощи сопоставления с образцом, если нас интересует несколько Option. Есть, вероятно, и другие способы сделать это, но код врядли станет заметно лучше. Так как мы имеем дело с Option в явном виде.</p>
<h3 id="а-теперь-с-монадными-трансформерами">А теперь с монадными трансформерами</h3>
<p>С монадными трансформерами мы можем удалить из кода всё лишнее и получить удобный инструмент для работы с подобными вложенными конструкциями. Scalaz предоставляет монадные трансформеры следующих типов:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">BijectionT
EitherT
IdT
IndexedContsT
LazyEitherT
LazyOptionT
ListT
MaybeT
OptionT
ReaderWriterStateT
ReaderT
StateT
StoreT
StreamT
UnWriterT
WriterT</code></pre></div>
<p>В то время как некоторые из них могут показаться немного экзотичными, ListT, OptionT, EitherT, ReaderT и WriterT имеют очень много вариантов использования. В первом примере мы сосредоточимся на монадном трансформере OptionT. Давайте посмотрим как мы можем создать монаду OptionT. В нашем случае нужно создать OptionT[Future, A], который упаковывает Option[A] внутрь Future. Мы можем создать его из A:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; :require /Users/jos/.<span class="fu">ivy2</span>/cache/org.<span class="fu">scalaz</span>/scalaz-core_2<span class="fl">.11</span>/bundles/scalaz-core_2<span class="fl">.11-7.2.1</span>.<span class="fu">jar</span>
Added &#39;/Users/jos/.<span class="fu">ivy2</span>/cache/org.<span class="fu">scalaz</span>/scalaz-core_2<span class="fl">.11</span>/bundles/scalaz-core_2<span class="fl">.11-7.2.1</span>.<span class="fu">jar</span>&#39; to classpath.

scala&gt; <span class="kw">import</span> scalaz.<span class="fu">_</span>
<span class="kw">import</span> scalaz.<span class="fu">_</span>

scala&gt; <span class="kw">import</span> Scalaz.<span class="fu">_</span>
<span class="kw">import</span> Scalaz.<span class="fu">_</span>                                ^

scala&gt; <span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">Future</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">Future</span>

scala&gt; <span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

scala&gt; <span class="kw">type</span> Result[A] = OptionT[Future, A]
defined <span class="kw">type</span> alias Result

scala&gt; <span class="fl">1234.</span>point[Result]
res1: Result[Int] = <span class="fu">OptionT</span>(scala.<span class="fu">concurrent</span>.<span class="fu">impl</span>.<span class="fu">Promise</span>$DefaultPromise@1c6ab85)

scala&gt; <span class="st">&quot;hello&quot;</span>.<span class="fu">point</span>[Result]
res2: Result[String] = <span class="fu">OptionT</span>(scala.<span class="fu">concurrent</span>.<span class="fu">impl</span>.<span class="fu">Promise</span>$DefaultPromise@<span class="fl">3e17219</span>)

scala&gt; res1.<span class="fu">run</span>
res4: scala.<span class="fu">concurrent</span>.<span class="fu">Future</span>[Option[Int]] = scala.<span class="fu">concurrent</span>.<span class="fu">impl</span>.<span class="fu">Promise</span>$DefaultPromise@1c6ab85</code></pre></div>
<p>Обратите внимание что мы явно определяем тип Result для того, чтобы функция point работала. Если вы этого не сделаете вы получите сообщение об ошибке:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="st">&quot;why&quot;</span>.<span class="fu">point</span>[OptionT[Future, String]]
&lt;console&gt;:<span class="dv">16</span>: error: scalaz.<span class="fu">OptionT</span>[scala.<span class="fu">concurrent</span>.<span class="fu">Future</span>,String] takes no <span class="kw">type</span> parameters, expected: one
              <span class="st">&quot;why&quot;</span>.<span class="fu">point</span>[OptionT[Future, String]]</code></pre></div>
<p>Вы можете использовать point только тогда, когда вы имеете дело с внутренним значением монадного трансформера. Если у вас уже есть Future или Option, придётся использовать конструктор OptionT.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="kw">val</span> p: Result[Int] = <span class="fu">OptionT</span>(Future.<span class="fu">successful</span>(<span class="fu">some</span>(<span class="dv">10</span>)))
p: Result[Int] = <span class="fu">OptionT</span>(scala.<span class="fu">concurrent</span>.<span class="fu">impl</span>.<span class="fu">Promise</span>$KeptPromise@40dde94)</code></pre></div>
<p>С монадными трансформерами вы можете автоматически развернуть вложенную монаду. Теперь, когда мы знаем как преобразовать наши значения к OptionT, давайте посмотрим как можно переписать предыдущий пример:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">withdrawWithMonadTransformers</span>(accountNumber: String, amount: Amount) : Future[Option[Statement]] = {

  <span class="kw">type</span> Result[A] = OptionT[Future, A]

  <span class="kw">val</span> result = <span class="kw">for</span> {
    account &lt;- <span class="fu">OptionT</span>(Accounts.<span class="fu">getAccount</span>(accountNumber))
    balance &lt;- <span class="fu">OptionT</span>(Accounts.<span class="fu">getBalance</span>(account))
    _ &lt;- <span class="fu">OptionT</span>(Accounts.<span class="fu">withdraw</span>(account,balance).<span class="fu">map</span>(<span class="fu">some</span>(_)))
    statement &lt;- Accounts.<span class="fu">getStatement</span>(account).<span class="fu">point</span>[Result]
  } <span class="kw">yield</span> statement

  result.<span class="fu">run</span>
}</code></pre></div>
<p>Неплохо правда? Вместо всей боли с приведением типов к корретным, мы просто создаём OptionT и возвращаем их. Для того чтобы получить сохранённое значение из OptionT мы просто вызываем run.</p>
<p>Несмотря на то что код стал уже гораздо лучше, мы всё ещё имеем много шума связанного с созданием OptionT.</p>
<h3 id="а-теперь-сделаем-наш-код-ещё-чище">А теперь сделаем наш код ещё чище</h3>
<p>Мы можем очистить наш код ещё немного:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Result[A] = OptionT[Future, A]

<span class="kw">object</span> ResultLike {
  <span class="kw">def</span> applyFO[A](a: Future[Option[A]]) : Result[A] = <span class="fu">OptionT</span>(a)
  <span class="kw">def</span> applyF[A](a: Future[A]) : Result[A] = <span class="fu">OptionT</span>(a.<span class="fu">map</span>(<span class="fu">some</span>(_)))
  <span class="kw">def</span> applyP[A](a: A) : Result[A] = a.<span class="fu">point</span>[Result]
}

<span class="kw">def</span> <span class="fu">withdrawClean</span>(accountNumber: String, amount: Amount) : Future[Option[Statement]] = {

  <span class="kw">val</span> result: Result[Statement] = <span class="kw">for</span> {
    account &lt;- Accounts.<span class="fu">getAccount</span>(accountNumber)         |&gt; ResultLike.<span class="fu">applyFO</span>
    balance &lt;- Accounts.<span class="fu">getBalance</span>(account)               |&gt; ResultLike.<span class="fu">applyFO</span>
    _ &lt;- Accounts.<span class="fu">withdraw</span>(account,balance)               |&gt; ResultLike.<span class="fu">applyF</span>
    statement &lt;- Accounts.<span class="fu">getStatement</span>(account)           |&gt; ResultLike.<span class="fu">applyP</span>
  } <span class="kw">yield</span> statement

  result.<span class="fu">run</span>
}</code></pre></div>
<p>При таком подходе мы просто создаём специальные конверторы, чтобы получить результат в монаде OptionT. В результате текущий for-генератор выглядит очень читаемо без какого-либо хлама. В правой части, не нагромождая “полезный” код, мы делаем преобразование в OptionT. Обратите внимание, что это не самое чистое решение так как нам приходится задавать разные apply функции. Перегрузка функций здесь не работает потому, что после стирания окончаний функции <code>applyFO</code> и <code>applyF</code> будут иметь одинаковую сигнатуру.</p>
<h2 id="монада-reader">Монада Reader</h2>
<p>Монада Reader одна из стандартных монад предоставляемых Scalaz. Монада Reader может быть использована для того чтобы выносить конфигурацию(или другие значения) и для таких вещей как инъекция зависимостей.</p>
<h3 id="решение-с-монадой-reader">Решение с монадой Reader</h3>
<p>Монада Reader позволяет делать инъекцию зависимостей в Scala. Независимо от того, является ли зависимость объектом конфигурации или ссылкой на какой-либо другой сервис. Мы начнём с примера который лучше всего объясняет как использовать монаду Reader.</p>
<p>Для этого примера предположим что у нас есть сервис, который требует Session, чтобы делать что-либо. Это может быть, например, сессия базы данных или что-то другое. Давайте в качестве примера возьмём код из предыдущего примера и немного его упростим убрав Future:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> AccountService {
  <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String, session: Session) : Option[Account]
  <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account, session: Session) : Option[Amount]
  <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount, session: Session) : Amount
  <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account, session: Session): Statement
}

<span class="kw">object</span> Accounts <span class="kw">extends</span> AccountService {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String, session: Session): Option[Account] = ???
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account, session: Session): Option[Amount] = ???
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount, session: Session): Amount = ???
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account, session: Session): Statement = ???
}</code></pre></div>
<p>Это немного раздражает, так как каждый раз, когда мы хотим вызвать один из сервисов, мы должны предоставить реализацию Session. Мы могли бы, конечно, сделать Session implicit’ом, но тогда нам нужно убедиться, что он находится в нашей области видимости, перед тем как вызывать функции этой службы. Было бы круто если бы мы могли внедрить эту сессию каким-нибудь образом. Мы могли бы, конечно, сделать это в конструкторе сервиса, но мы можем так же использовать монаду Reader для этого:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// введение в тип Action. Он представляет из себя действие которое наш сервис может выполнить.</span>
<span class="co">// Как вы видите Action требует Session.</span>
<span class="kw">type</span> Action[A] = Reader[Session, A]

<span class="kw">trait</span> AccountService {
  <span class="co">// возвращает аккаунт или None, когда аккаунт не найден</span>
  <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String) : Action[Option[Account]]
  <span class="co">// возвращает баланс если аккаунт открыт или None иначе</span>
  <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account) :Action[Option[Amount]]
  <span class="co">// снять сумму со счета, и вернуть новое значение</span>
  <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount) : Action[Amount]
  <span class="co">// мы можем также получить обзор выписки со счета</span>
  <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account): Action[Statement]
}

<span class="kw">object</span> Accounts <span class="kw">extends</span> AccountService {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String): Action[Option[Account]] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="fu">some</span>(<span class="fu">Account</span>())
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account): Action[Option[Amount]] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="fu">some</span>(<span class="fu">Amount</span>(<span class="dv">10</span>,<span class="st">&quot;Dollar&quot;</span>))
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount): Action[Amount] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="fu">Amount</span>(<span class="dv">5</span>, <span class="st">&quot;Dollar&quot;</span>)
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account): Action[Statement] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    Statement(account)
  })
}</code></pre></div>
<p>Как вы можете видеть, мы не возвращаем результат, но оборачиваем его в Reader. Самое замечательное в том, что теперь мы можем начать обрабатывать результат, так как Reader это просто монада.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">withdrawWithReader</span>(accountNumber: String) = {

  <span class="kw">for</span> {
    account &lt;- Accounts.<span class="fu">getAccount</span>(accountNumber)
    balance &lt;- account.<span class="fu">fold</span>(Reader((session: Session) =&gt; none[Amount]))(ac =&gt; Accounts.<span class="fu">getBalance</span>(ac))
    _ &lt;- (account, balance) <span class="kw">match</span> {
      <span class="kw">case</span> (Some(acc), Some(bal)) =&gt; Accounts.<span class="fu">withdraw</span>(acc,bal)
      <span class="kw">case</span> _ =&gt; Reader((session: Session) =&gt; none[Amount])
    }
  statement &lt;- account <span class="kw">match</span> { <span class="kw">case</span> Some(acc) =&gt; Accounts.<span class="fu">getStatement</span>(acc)}
  } <span class="kw">yield</span> statement
}</code></pre></div>
<p>Данный код не вернёт нам фактическое конечное значение, но вернёт Reader. Теперь мы можем запустить код передав Session:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// функция возвращает &#39;шаги&#39; для выполнения, чтобы выполнить эти шаги, нужно запустить run в контексте &#39;новой сессии&#39;</span>
<span class="fu">withdrawWithReader</span>(<span class="st">&quot;1234&quot;</span>).<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">Session</span>())</code></pre></div>
<p>Когда вы вновь посмотрите на withdrawWithReader вы увидите, что мы вновь должны работать с монадой Option в явном виде и убедиться, что мы всегда создаём Reader в качестве результата. К счастью, Scalaz предоставляет ReaderT. В следующем коде мы покажем, как это делается на примере:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// введение в тип Action. Он представляет из себя действие которое наш сервис может выполнить.</span>
<span class="co">// Как вы видите Action требует Session.</span>
<span class="kw">type</span> Action[A] = ReaderT[Session, A]

<span class="kw">trait</span> AccountService {
  <span class="co">// возвращает аккаунт или None, когда аккаунт не найден</span>
  <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String) : Action[Option[Account]]
  <span class="co">// возвращает баланс если аккаунт открыт или None иначе</span>
  <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account) :Action[Option[Amount]]
  <span class="co">// снять сумму со счета, и вернуть новое значение</span>
  <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount) : Action[Amount]
  <span class="co">// мы можем также получить обзор выписки со счета</span>
  <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account): Action[Statement]
}

<span class="kw">object</span> Accounts <span class="kw">extends</span> AccountService {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String): Action[Option[Account]] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="fu">some</span>(<span class="fu">Account</span>())
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account): Action[Option[Amount]] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="fu">some</span>(<span class="fu">Amount</span>(<span class="dv">10</span>,<span class="st">&quot;Dollar&quot;</span>))
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount): Action[Amount] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="fu">Amount</span>(<span class="dv">5</span>, <span class="st">&quot;Dollar&quot;</span>)
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account): Action[Statement] = Reader((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    Statement(account)
  })
}

<span class="kw">def</span> <span class="fu">withdrawWithReaderT</span>(accountNumber: String) = {
  <span class="kw">for</span> {
    account &lt;- Accounts.<span class="fu">getAccount</span>(accountNumber)
    balance &lt;- Accounts.<span class="fu">getBalance</span>(account)
    _ &lt;- Accounts.<span class="fu">withdraw</span>(account, balance)
    statement &lt;- Accounts.<span class="fu">getStatement</span>(account)
  } <span class="kw">yield</span> statement
}

<span class="fu">withdrawWithReaderT</span>(<span class="st">&quot;1234&quot;</span>).<span class="fu">run</span>(<span class="kw">new</span> Session)</code></pre></div>
<p>Как вы видите не многое изменилось. Главное, что мы изменили это определение Action, он теперь использует ReaderT вместо Reader. Мы изменили трейт и его реализацию для того чтобы работать с ним. Теперь, когда вы посмотрите на функцию withdrawWithReaderT вы увидите что нам больше не нужно обрабатывать Option, но он обрабатывается нашим ReaderT(который на самом деле является Kleisli, но это тема для другой статьи). Круто, правда?</p>
<p>Мы видим что это отлично работает для Option, что случится если мы вернёмся назад к оригинальному примеру и захотим использовать Option внутри Future и это всё внутри Reader? Ну этот момент выходит за рамки “Scalaz функций для повседневного использования”, но базовый подход такой же:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// введение в тип Action. Он представляет из себя действие которое наш сервис может выполнить.</span>
<span class="co">// Как вы видите Action требует Session.</span>
<span class="kw">type</span> OptionTF[A] = OptionT[Future, A]
<span class="kw">type</span> Action[A] = ReaderT[OptionTF, Session, A]

<span class="kw">trait</span> AccountService {
  <span class="co">// возвращает аккаунт или None, когда аккаунт не найден</span>
  <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String) : Action[Account]
  <span class="co">// возвращает баланс если аккаунт открыт или None иначе</span>
  <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account) :Action[Amount]
  <span class="co">// снять сумму со счета, и вернуть новое значение</span>
  <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount) : Action[Amount]
  <span class="co">// мы можем также получить обзор выписки со счета</span>
  <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account): Action[Statement]
}

<span class="kw">object</span> Accounts <span class="kw">extends</span> AccountService {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getAccount</span>(accountNumber: String): Action[Account] = <span class="fu">ReaderT</span>((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="co">// предположим мы получаем Future[Option[Account]]</span>
    <span class="kw">val</span> result = Future(Option(<span class="fu">Account</span>()))

    <span class="co">// и нам нужно поднять её в OptionTF и вернуть его</span>
    <span class="kw">val</span> asOptionTF: OptionTF[Account] = <span class="fu">OptionT</span>(result)
    asOptionTF
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getBalance</span>(account: Account): Action[Amount] = <span class="fu">ReaderT</span>((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="co">// предположим мы получаем Future[Option[Amount]]</span>
    <span class="kw">val</span> result = Future(<span class="fu">some</span>(<span class="fu">Amount</span>(<span class="dv">10</span>,<span class="st">&quot;Dollar&quot;</span>)))
    <span class="co">// преобразуем это к типу Action c явным типом чтобы сделать компилятор счастливым</span>
    <span class="kw">val</span> asOptionTF: OptionTF[Amount] = <span class="fu">OptionT</span>(result)
    asOptionTF
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">withdraw</span>(account: Account, amount: Amount): Action[Amount] = <span class="fu">ReaderT</span>((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="co">// предположим мы получаем Future[Amount]</span>
    <span class="kw">val</span> result = Future(<span class="fu">Amount</span>(<span class="dv">5</span>, <span class="st">&quot;Dollar&quot;</span>))
    <span class="co">// приводим к корректному типу</span>
    <span class="kw">val</span> asOptionTF: OptionTF[Amount] = <span class="fu">OptionT</span>(result.<span class="fu">map</span>(<span class="fu">some</span>(_)))
    asOptionTF
  })

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">getStatement</span>(account: Account): Action[Statement] = <span class="fu">ReaderT</span>((session: Session) =&gt; {
    <span class="co">// сделать что-нибудь с сессией здесь и вернуть результат</span>
    session.<span class="fu">doSomething</span>
    <span class="co">// предположим мы получаем Statement</span>
    <span class="kw">val</span> result = Statement(account)
    <span class="co">// приведём к корректному типу</span>
    result.<span class="fu">point</span>[OptionTF]
  })
}

<span class="kw">def</span> <span class="fu">withdrawWithReaderT</span>(accountNumber: String) = {
  <span class="kw">for</span> {
    account &lt;- Accounts.<span class="fu">getAccount</span>(accountNumber)
    balance &lt;- Accounts.<span class="fu">getBalance</span>(account)
    _ &lt;- Accounts.<span class="fu">withdraw</span>(account, balance)
    statement &lt;- Accounts.<span class="fu">getStatement</span>(account)
  } <span class="kw">yield</span> statement
}

<span class="co">// это результат завёрнутый в Option</span>
<span class="kw">val</span> finalResult = <span class="fu">withdrawWithReaderT</span>(<span class="st">&quot;1234&quot;</span>).<span class="fu">run</span>(<span class="kw">new</span> Session)
<span class="co">// получаем Future[Option] и ждём результата</span>
<span class="fu">println</span>(Await.<span class="fu">result</span>(finalResult.<span class="fu">run</span>, <span class="dv">5</span> seconds))</code></pre></div>
<p>Мы определили другой тип ReaderT, в который положили OptionT вместо просто Option. Этот OptionT будет обрабатывать преобразования Option/Future. Так как мы получили новый ReaderT, нам, конечно, нужно поднять результаты вызовов нашего сервиса к этой монаде, которые нуждаются в несколько насильственном приведении для того чтобы компилятор всё понял. Результат будет очень приятным. Текущий for-генератор остаётся точно таким же, но на этот раз может обрабатывать Option внутри Future внутри Reader!</p>
<h3 id="заключение">Заключение</h3>
<p>В этой статье мы рассмотрели две вещи из Scalaz, которые действительно пригодятся при работе с вложенными монадами или если вы хотите лучше управлять зависимостями между компонентами. Особенно крут тот факт, что довольно легко использовать монадные трансформеры вместе с монадой Reader. В результате, сделав пару небольших шагов мы можем полностью скрыть детали реализации(в данном случае) связанные с Future и Option, и получить очень красивые и чистые for-генераторы и другие монадические вкусности.</p>
<p><a href="http://www.smartjava.org/content/scalaz-features-everyday-usage-part-2-monad-transformers-and-reader-monad">Оригинальная статья.</a></p>

  <div id="socialButtons">
    <script type="text/javascript" src="//yastatic.net/es5-shims/0.0.2/es5-shims.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="//yastatic.net/share2/share.js" charset="utf-8"></script>
    <div class="ya-share2" data-services="vkontakte,facebook,linkedin,gplus,twitter,blogger,reddit,evernote,lj,pocket" data-counter=""></div>
  </div>

  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'beizeroblog'; // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
]]></summary>
</entry>
<entry>
    <title>Scalaz для ежедневного использования. Часть 1: Классы типов и расширения Scala.</title>
    <link href="/posts/2016-06-04-scalaz-features-for-everyday-usage-part-1.html" />
    <id>/posts/2016-06-04-scalaz-features-for-everyday-usage-part-1.html</id>
    <published>2016-06-04T00:00:00Z</published>
    <updated>2016-06-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="blog-post">
  <h2 class="blog-post-title">
    Scalaz для ежедневного использования. Часть 1: Классы типов и расширения Scala.
  </h2>
  <p class="blog-post-meta">
    <span class="date">2016-06-04</span> - <span class="tags"><a href="/tags/scala.html">scala</a>, <a href="/tags/scalaz%20%D0%B4%D0%BB%D1%8F%20%D0%B5%D0%B6%D0%B5%D0%B4%D0%BD%D0%B5%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.html">scalaz для ежедневного использования</a>, <a href="/tags/scalaz.html">scalaz</a>, <a href="/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4.html">перевод</a></span>
  <p>Многие из вас наверно слышали о замечательной JavaScript книге “JavaScript the good parts”. В подобном ключе я бы хотел рассказать о некоторых вещах из Scalaz, которые действительно здорово использовать в повседневных проектах без необходимости вникать в то что происходит внутри Scalaz. В первой части мы рассмотрим несколько полезных классов типов. В будущих частях мы рассмотрим такие вещи как монадные трансформеры, свободные монады, Validation и т.д.</p>
<!--more-->
<p>В наших примерах мы будем использовать Scala REPL. Для этого запустим <code>scala</code>, добавим библиотеку scalaz и импортируем нужные нам пакеты:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; :require /Users/jos/.<span class="fu">ivy2</span>/cache/org.<span class="fu">scalaz</span>/scalaz-core_2<span class="fl">.11</span>/bundles/scalaz-core_2<span class="fl">.11-7.2.1</span>.<span class="fu">jar</span>
Added &#39;/Users/jos/.<span class="fu">ivy2</span>/cache/org.<span class="fu">scalaz</span>/scalaz-core_2<span class="fl">.11</span>/bundles/scalaz-core_2<span class="fl">.11-7.2.1</span>.<span class="fu">jar</span>&#39; to classpath.

scala&gt; <span class="kw">import</span> scalaz.<span class="fu">_</span>
<span class="kw">import</span> scalaz.<span class="fu">_</span>

scala&gt; <span class="kw">import</span> Scalaz.<span class="fu">_</span>
<span class="kw">import</span> Scalaz.<span class="fu">_</span></code></pre></div>
<p>В данной статье мы рассмотрим следующие классы типов из библиотеки Scalaz:</p>
<ol style="list-style-type: decimal">
<li>Equals: для типобезопасной операции сравнения на равенство.</li>
<li>Order: для немного более типобезопасного отношения порядка.</li>
<li>Enum: для создания богатых типов перечеслений.</li>
</ol>
<p>Кроме того, мы также рассмотрим несколько простых расширений, которые добавляет Scalaz, для некоторых типов из стандартной библиотеки. Мы не будем рассматривать всё что добавляет Scalaz и остановимся на паре расширений для Option и Boolean.</p>
<h3 id="полезные-классы-типов">Полезные классы типов</h3>
<p>С помощью классов типов можно легко добавить функциональность к существующим классам. Scalaz уже содержит в себе несколько полезных классов типов, которые вы можете сразу же использовать.</p>
<h4 id="типобезопасный-оператор-сравнения">Типобезопасный оператор сравнения</h4>
<p>В Scalaz есть типобезопасный оператор сравнения на равенство, который выдаёт ошибку компиляции если мы пытаемся сравнить объекты разных типов. Таким образом, в то время как <code>==</code> и <code>!=</code> из стандартной библиотеки позволят вам сравнивать, например, объекты классов String и Int, использование операторов <code>===</code> и <code>=/=</code> из Scalaz приведет к ошибке компиляции:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="dv">1</span> == <span class="dv">1</span>
res6: Boolean = <span class="kw">true</span>
scala&gt; <span class="dv">1</span> === <span class="dv">1</span>
res7: Boolean = <span class="kw">true</span>
scala&gt; <span class="dv">1</span> == <span class="st">&quot;1&quot;</span>
res8: Boolean = <span class="kw">false</span>
scala&gt; <span class="dv">1</span> === <span class="st">&quot;1&quot;</span>
&lt;console&gt;:<span class="dv">14</span>: error: <span class="kw">type</span> mismatch;
 found   : String(<span class="st">&quot;1&quot;</span>)
 required: Int
              <span class="dv">1</span> === <span class="st">&quot;1&quot;</span></code></pre></div>
<p>Scalaz предоставляет следующий набор операторов поведение которых легко понять из реализации:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">def</span> ===(other: F): Boolean = F.<span class="fu">equal</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> /==(other: F): Boolean = !F.<span class="fu">equal</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> =/=(other: F): Boolean = /==(other)
<span class="kw">final</span> <span class="kw">def</span> ≟(other: F): Boolean = F.<span class="fu">equal</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> ≠(other: F): Boolean = !F.<span class="fu">equal</span>(self, other)</code></pre></div>
<h4 id="класс-типов-order">Класс типов Order</h4>
<p>Этот очень простой класс типов позволяет более типобезопасно пользоваться отношением порядка. Так же, как и с операторами из Equals теперь мы можем поймать сравнение двух объектов разных типов во время компиляции:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="dv">1</span> &lt; 4d
res25: Boolean = <span class="kw">true</span>

scala&gt; <span class="dv">1</span> lte 4d
&lt;console&gt;:<span class="dv">14</span>: error: <span class="kw">type</span> mismatch;
 found   : Double(<span class="fl">4.0</span>)
 required: Int
              <span class="dv">1</span> lte 4d

scala&gt; <span class="dv">1</span> ?|? <span class="dv">1</span>
res31: scalaz.<span class="fu">Ordering</span> = EQ

scala&gt; <span class="dv">1</span> ?|? <span class="dv">2</span>
res32: scalaz.<span class="fu">Ordering</span> = LT

scala&gt; <span class="dv">1</span> ?|? 2d
&lt;console&gt;:<span class="dv">14</span>: error: <span class="kw">type</span> mismatch;
 found   : Double(<span class="fl">2.0</span>)
 required: Int
              <span class="dv">1</span> ?|? 2d</code></pre></div>
<p>Scalaz предоставляет для этого следующие операторы:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">def</span> &lt;(other: F): Boolean = F.<span class="fu">lessThan</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> &lt;=(other: F): Boolean = F.<span class="fu">lessThanOrEqual</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> &gt;(other: F): Boolean = F.<span class="fu">greaterThan</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> &gt;=(other: F): Boolean = F.<span class="fu">greaterThanOrEqual</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">max</span>(other: F): F = F.<span class="fu">max</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">min</span>(other: F): F = F.<span class="fu">min</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">cmp</span>(other: F): Ordering = F.<span class="fu">order</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> ?|?(other: F): Ordering = F.<span class="fu">order</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">lte</span>(other: F): Boolean = F.<span class="fu">lessThanOrEqual</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">gte</span>(other: F): Boolean = F.<span class="fu">greaterThanOrEqual</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">lt</span>(other: F): Boolean = F.<span class="fu">lessThan</span>(self, other)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">gt</span>(other: F): Boolean = F.<span class="fu">greaterThan</span>(self, other)</code></pre></div>
<h4 id="класс-типов-enum">Класс типов Enum</h4>
<p>С Enum из Scalaz очень легко создавать типы перечисления, которые имеют больше функциональных возможностей, чем те, что находятся в стандартных библиотеках Scala и Java. Scalaz предоставляет для этого следующие функции:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">def</span> succ: F = F succ self
<span class="kw">final</span> <span class="kw">def</span> -+-(n: Int): F = F.<span class="fu">succn</span>(n, self)
<span class="kw">final</span> <span class="kw">def</span> succx: Option[F] = F.<span class="fu">succx</span>.<span class="fu">apply</span>(self)
<span class="kw">final</span> <span class="kw">def</span> pred: F = F pred self
<span class="kw">final</span> <span class="kw">def</span> ---(n: Int): F = F.<span class="fu">predn</span>(n, self)
<span class="kw">final</span> <span class="kw">def</span> predx: Option[F] = F.<span class="fu">predx</span>.<span class="fu">apply</span>(self)
<span class="kw">final</span> <span class="kw">def</span> from: EphemeralStream[F] = F.<span class="fu">from</span>(self)
<span class="kw">final</span> <span class="kw">def</span> <span class="fu">fromStep</span>(step: Int): EphemeralStream[F] = F.<span class="fu">fromStep</span>(step, self)
<span class="kw">final</span> <span class="kw">def</span> |=&gt;(to: F): EphemeralStream[F] = F.<span class="fu">fromTo</span>(self, to)
<span class="kw">final</span> <span class="kw">def</span> |-&gt;(to: F): List[F] = F.<span class="fu">fromToL</span>(self, to)
<span class="kw">final</span> <span class="kw">def</span> |==&gt;(step: Int, to: F): EphemeralStream[F] = F.<span class="fu">fromStepTo</span>(step, self, to)
<span class="kw">final</span> <span class="kw">def</span> |--&gt;(step: Int, to: F): List[F] = F.<span class="fu">fromStepToL</span>(step, self, to)</code></pre></div>
<p>Очень хороший пример можно найти на <a href="http://stackoverflow.com/questions/28589022/enumeration-concept-in-scala-which-option-to-take">StackOverflow</a>, который всё же требует нескольких изменений для того чтобы получить все вкусности Scala. Следующий код показывает как использовать данное перечесление:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="kw">import</span> scalaz.<span class="fu">Ordering</span>.<span class="fu">_</span>
<span class="kw">import</span> scalaz.<span class="fu">Ordering</span>.<span class="fu">_</span>

scala&gt; :paste
<span class="co">// Entering paste mode (ctrl-D to finish)</span>

  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Coloring</span>(<span class="kw">val</span> toInt: Int, <span class="kw">val</span> name: String)

  <span class="kw">object</span> Coloring <span class="kw">extends</span> ColoringInstances {

    <span class="kw">val</span> RED = <span class="fu">Coloring</span>(<span class="dv">1</span>, <span class="st">&quot;RED&quot;</span>)
    <span class="kw">val</span> BLUE = <span class="fu">Coloring</span>(<span class="dv">1</span>, <span class="st">&quot;BLUE&quot;</span>)
    <span class="kw">val</span> GREEN = <span class="fu">Coloring</span>(<span class="dv">1</span>, <span class="st">&quot;GREEN&quot;</span>)
  }

  <span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> ColoringInstances {

    <span class="kw">import</span> Coloring.<span class="fu">_</span>

    <span class="kw">implicit</span> <span class="kw">val</span> coloringInstance: Enum[Coloring] <span class="kw">with</span> Show[Coloring] = <span class="kw">new</span> Enum[Coloring] <span class="kw">with</span> Show[Coloring] {

      <span class="kw">def</span> <span class="fu">order</span>(a1: Coloring, a2: Coloring): Ordering = (a1, a2) <span class="kw">match</span> {
        <span class="kw">case</span> (RED, RED) =&gt; EQ
        <span class="kw">case</span> (RED, BLUE | GREEN) =&gt; LT
        <span class="kw">case</span> (BLUE, BLUE) =&gt; EQ
        <span class="kw">case</span> (BLUE, GREEN) =&gt; LT
        <span class="kw">case</span> (BLUE, RED) =&gt; GT
        <span class="kw">case</span> (GREEN, RED) =&gt; GT
        <span class="kw">case</span> (GREEN, BLUE) =&gt; GT
        <span class="kw">case</span> (GREEN, GREEN) =&gt; EQ
      }

      <span class="kw">def</span> <span class="fu">append</span>(c1: Coloring, c2: =&gt; Coloring): Coloring = c1 <span class="kw">match</span> {
        <span class="kw">case</span> Coloring.<span class="fu">RED</span> =&gt; c2
        <span class="kw">case</span> o =&gt; o
      }

      <span class="kw">override</span> <span class="kw">def</span> <span class="fu">shows</span>(c: Coloring) = c.<span class="fu">name</span>

      <span class="kw">def</span> zero: Coloring = Coloring.<span class="fu">RED</span>

      <span class="kw">def</span> <span class="fu">succ</span>(c: Coloring) = c <span class="kw">match</span> {
        <span class="kw">case</span> Coloring.<span class="fu">RED</span> =&gt; Coloring.<span class="fu">BLUE</span>
        <span class="kw">case</span> Coloring.<span class="fu">BLUE</span> =&gt; Coloring.<span class="fu">GREEN</span>
        <span class="kw">case</span> Coloring.<span class="fu">GREEN</span> =&gt; Coloring.<span class="fu">RED</span>
      }

      <span class="kw">def</span> <span class="fu">pred</span>(c: Coloring) = c <span class="kw">match</span> {
        <span class="kw">case</span> Coloring.<span class="fu">GREEN</span> =&gt; Coloring.<span class="fu">BLUE</span>
        <span class="kw">case</span> Coloring.<span class="fu">BLUE</span> =&gt; Coloring.<span class="fu">RED</span>
        <span class="kw">case</span> Coloring.<span class="fu">RED</span> =&gt; Coloring.<span class="fu">GREEN</span>
      }

      <span class="kw">override</span> <span class="kw">def</span> max = Some(GREEN)

      <span class="kw">override</span> <span class="kw">def</span> min = Some(RED)

    }
  }

<span class="co">// Exiting paste mode, now interpreting.</span>

defined <span class="kw">class</span> Coloring
defined <span class="kw">object</span> Coloring
defined <span class="kw">class</span> ColoringInstances</code></pre></div>
<p>Теперь мы можем использовать все функции определённые в Scalaz Enum:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="kw">import</span> Coloring.<span class="fu">_</span>
<span class="kw">import</span> Coloring.<span class="fu">_</span>

scala&gt; RED
res0: Coloring = <span class="fu">Coloring</span>(<span class="dv">1</span>,RED)

scala&gt; GREEN
res1: Coloring = <span class="fu">Coloring</span>(<span class="dv">1</span>,GREEN)

scala&gt; RED |-&gt; GREEN
res2: List[Coloring] = List(<span class="fu">Coloring</span>(<span class="dv">1</span>,RED), <span class="fu">Coloring</span>(<span class="dv">1</span>,BLUE), <span class="fu">Coloring</span>(<span class="dv">1</span>,GREEN))

scala&gt; RED succ
warning: there was one feature warning; re-run <span class="kw">with</span> -feature <span class="kw">for</span> details
res3: Coloring = <span class="fu">Coloring</span>(<span class="dv">1</span>,BLUE)

scala&gt; RED -+- <span class="dv">1</span>
res4: Coloring = <span class="fu">Coloring</span>(<span class="dv">1</span>,BLUE)

scala&gt; RED -+- <span class="dv">2</span>
res5: Coloring = <span class="fu">Coloring</span>(<span class="dv">1</span>,GREEN)</code></pre></div>
<p>Правда впечатляет? Это действительно очень хороший способ создания гибких и богатых перечислений.</p>
<h3 id="расширения-стандартных-классов">Расширения стандартных классов</h3>
<p>Как мы уже говорили в начале статьи, мы рассмотрим как Scalaz делает стандартную библиотеку более богатой и добавляет новую функциональность к стандартным классам.</p>
<h4 id="веселимся-с-option">Веселимся с Option</h4>
<p>С классом типов Optional Scalaz делает работу с Option проще. Например, он предоставляет функции для более простого конструирования:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; Some(<span class="dv">10</span>)
res11: Some[Int] = Some(<span class="dv">10</span>)

scala&gt; None
res12: None.<span class="fu">type</span> = None

scala&gt; <span class="fu">some</span>(<span class="dv">10</span>)
res13: Option[Int] = Some(<span class="dv">10</span>)

scala&gt; none[Int]
res14: Option[Int] = None</code></pre></div>
<p>Мы видим что результирующим типом является Option[T] вместо Some или None. Вам может быть не понятно где это может быть полезно, но давайте рассмотрим следующую ситуацию: скажем, у нас есть список Option к которому мы хотим применить свёртку:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="kw">val</span> l = List(Some(<span class="dv">10</span>), Some(<span class="dv">20</span>), None, Some(<span class="dv">30</span>))
l: List[Option[Int]] = List(Some(<span class="dv">10</span>), Some(<span class="dv">20</span>), None, Some(<span class="dv">30</span>))

scala&gt; l.<span class="fu">foldLeft</span>(None) { (el, z) =&gt; el.<span class="fu">orElse</span>(z)  }
&lt;console&gt;:<span class="dv">22</span>: error: <span class="kw">type</span> mismatch;
 found   : Option[Int]
 required: None.<span class="fu">type</span>
              l.<span class="fu">foldLeft</span>(None) { (el, z) =&gt; el.<span class="fu">orElse</span>(z)  }</code></pre></div>
<p>Данный код упадёт с ошибкой, потому что результат свёртки должен быть None.type, а не Option. Когда мы используем функции из Scalaz это работает так как мы и ожидали:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; l.<span class="fu">foldLeft</span>(none[Int]) { (el, z) =&gt; el.<span class="fu">orElse</span>(z)  }
res19: Option[Int] = Some(<span class="dv">10</span>)</code></pre></div>
<p>И конечно же Scalaz добавляет новых операторов:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Альтернатива getOrElse</span>
scala&gt; Some(<span class="dv">10</span>) | <span class="dv">20</span>
res29: Int = <span class="dv">10</span>

scala&gt; none | <span class="dv">10</span>
res30: Int = <span class="dv">10</span>

<span class="co">// Тернарный оператор</span>
scala&gt; Some(<span class="dv">10</span>) ? <span class="dv">5</span> | <span class="dv">4</span>
res31: Int = <span class="dv">5</span>

<span class="co">// ~ : Возвращает элемент хранимый в Option, если он там есть, а иначе &quot;ноль&quot; типа A</span>
scala&gt; <span class="fu">some</span>(List())
res32: Option[List[Nothing]] = Some(List())

scala&gt; ~res32
res33: List[Nothing] = List()

scala&gt; <span class="fu">some</span>(List(<span class="dv">10</span>))
res34: Option[List[Int]] = Some(List(<span class="dv">10</span>))

scala&gt; ~res34
res35: List[Int] = List(<span class="dv">10</span>)</code></pre></div>
<p>Ничего слишком сложного, просто несколько вспомогательных функций. Существует множество двугих интересных вещей вокруг Option в Scalaz, но это уже выходит за рамки данной статьи.</p>
<h4 id="более-функциональный-boolean">Более функциональный Boolean</h4>
<p>Scalaz так же добавляет больше функциональности к типу Boolean:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"># Тернарный опертор возвращается!
scala&gt; <span class="kw">true</span> ? <span class="st">&quot;This is true&quot;</span> | <span class="st">&quot;This is false&quot;</span>
res45: String = This is <span class="kw">true</span>

scala&gt; <span class="kw">false</span> ? <span class="st">&quot;This is true&quot;</span> | <span class="st">&quot;This is false&quot;</span>
res46: String = This is <span class="kw">false</span>

# Возвращает передаваемый аргумент в случае <span class="kw">true</span>, иначе возвращает <span class="st">&quot;ноль&quot;</span> типа A
scala&gt; <span class="kw">false</span> ?? List(<span class="dv">120</span>,<span class="dv">20321</span>)
res55: List[Int] = List()

scala&gt; <span class="kw">true</span> ?? List(<span class="dv">120</span>,<span class="dv">20321</span>)
res56: List[Int] = List(<span class="dv">120</span>, <span class="dv">20321</span>)</code></pre></div>
<p>И целый список операторов для бинарной арифметики:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Conjunction. (AND)</span>
<span class="kw">final</span> <span class="kw">def</span> ∧(q: =&gt; Boolean) = b.<span class="fu">conjunction</span>(self, q)
<span class="co">// Conjunction. (AND)</span>
<span class="kw">final</span> <span class="kw">def</span> /\(q: =&gt; Boolean) = ∧(q)
<span class="co">// Disjunction. (OR)</span>
<span class="kw">final</span> <span class="kw">def</span> ∨(q: =&gt; Boolean): Boolean = b.<span class="fu">disjunction</span>(self, q)
<span class="co">// Disjunction. (OR)</span>
<span class="kw">final</span> <span class="kw">def</span> \/(q: =&gt; Boolean): Boolean = ∨(q)
<span class="co">// Negation of Disjunction. (NOR)</span>
<span class="kw">final</span> <span class="kw">def</span> !||(q: =&gt; Boolean) = b.<span class="fu">nor</span>(self, q)
<span class="co">// Negation of Conjunction. (NAND)</span>
<span class="kw">final</span> <span class="kw">def</span> !&amp;&amp;(q: =&gt; Boolean) = b.<span class="fu">nand</span>(self, q)
<span class="co">// Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> --&gt;(q: =&gt; Boolean) = b.<span class="fu">conditional</span>(self, q)
<span class="co">// Inverse Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> &lt;--(q: =&gt; Boolean) = b.<span class="fu">inverseConditional</span>(self, q)
<span class="co">// Bi-Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> &lt;--&gt;(q: =&gt; Boolean) = b.<span class="fu">conditional</span>(self, q) &amp;&amp; b.<span class="fu">inverseConditional</span>(self, q)
<span class="co">// Inverse Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> ⇐(q: =&gt; Boolean) = b.<span class="fu">inverseConditional</span>(self, q)
<span class="co">// Negation of Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> ⇏(q: =&gt; Boolean) = b.<span class="fu">negConditional</span>(self, q)
<span class="co">// Negation of Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> -/&gt;(q: =&gt; Boolean) = b.<span class="fu">negConditional</span>(self, q)
<span class="co">// Negation of Inverse Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> ⇍(q: =&gt; Boolean) = b.<span class="fu">negInverseConditional</span>(self, q)
<span class="co">// Negation of Inverse Conditional.</span>
<span class="kw">final</span> <span class="kw">def</span> &lt;\-(q: =&gt; Boolean) = b.<span class="fu">negInverseConditional</span>(self, q)</code></pre></div>
<p>Например:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="kw">true</span> /\ <span class="kw">true</span>
res57: Boolean = <span class="kw">true</span>

scala&gt; <span class="kw">true</span> /\ <span class="kw">false</span>
res58: Boolean = <span class="kw">false</span>

scala&gt; <span class="kw">true</span> !&amp;&amp; <span class="kw">false</span>
res59: Boolean = <span class="kw">true</span></code></pre></div>
<h4 id="больше-дополнительных-функций">Больше дополнительных функций</h4>
<p>В данной статье мы рассмотрели всего несколько дополнительных функций из Scalaz. Если вас заинтересовала эта тема вам стоит заглянуть в код следующих классов:</p>
<ul>
<li>scalaz.syntax.std.BooleanOps</li>
<li>scalaz.syntax.std.ListOps</li>
<li>scalaz.syntax.std.MapOps</li>
<li>scalaz.syntax.std.OptionOps</li>
<li>scalaz.syntax.std.StringOps</li>
</ul>
<p>Ещё немного примеров:</p>
<h4 id="балуемся-с-list">Балуемся с List</h4>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"># взять хвост как Option
scala&gt; List(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>)
res60: List[Int] = List(<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>)

scala&gt; res60.<span class="fu">tailOption</span>
res61: Option[List[Int]] = Some(List(<span class="dv">20</span>, <span class="dv">30</span>))

scala&gt; List()
res64: List[Nothing] = List()

scala&gt; res64.<span class="fu">tailOption</span>
res65: Option[List[Nothing]] = None

# <span class="st">&quot;усыпать&quot;</span> список дополнительными элементами
scala&gt; List(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>)
res66: List[Int] = List(<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>)

scala&gt; res66.<span class="fu">intersperse</span>(<span class="dv">1</span>)
res68: List[Int] = List(<span class="dv">10</span>, <span class="dv">1</span>, <span class="dv">20</span>, <span class="dv">1</span>, <span class="dv">30</span>)

# всевозможные перестановки списка
scala&gt; List(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;).<span class="fu">powerset</span>
res71: List[List[Char]] = List(List(a, b, c, d), List(a, b, c), List(a, b, d), List(a, b), List(a, c, d), List(a, c), List(a, d), List(a), List(b, c, d), List(b, c), List(b, d), List(b), List(c, d), List(c), List(d), List())</code></pre></div>
<h4 id="забавляемся-с-map">Забавляемся с Map</h4>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"># безопасно изменить запись
res77: scala.<span class="fu">collection</span>.<span class="fu">immutable</span>.<span class="fu">Map</span>[Char,Int] = Map(a -&gt; <span class="dv">10</span>, b -&gt; <span class="dv">20</span>)
scala&gt; res77.<span class="fu">alter</span>(&#39;a&#39;)(f =&gt; f |+| <span class="fu">some</span>(<span class="dv">5</span>))
res78: Map[Char,Int] = Map(a -&gt; <span class="dv">15</span>, b -&gt; <span class="dv">20</span>)

# пересечь два Map&#39;а и определить какое значение оставить для каждого из ключей
scala&gt; <span class="kw">val</span> m1 =  Map(&#39;a&#39; -&gt; <span class="dv">100</span>, &#39;b&#39; -&gt; <span class="dv">200</span>, &#39;c&#39; -&gt; <span class="dv">300</span>)
m1: scala.<span class="fu">collection</span>.<span class="fu">immutable</span>.<span class="fu">Map</span>[Char,Int] = Map(a -&gt; <span class="dv">100</span>, b -&gt; <span class="dv">200</span>, c -&gt; <span class="dv">300</span>)

scala&gt; <span class="kw">val</span> m2 = Map(&#39;b&#39; -&gt; <span class="dv">2000</span>, &#39;c&#39; -&gt; <span class="dv">3000</span>, &#39;d&#39; -&gt; <span class="dv">4000</span>)
m2: scala.<span class="fu">collection</span>.<span class="fu">immutable</span>.<span class="fu">Map</span>[Char,Int] = Map(b -&gt; <span class="dv">2000</span>, c -&gt; <span class="dv">3000</span>, d -&gt; <span class="dv">4000</span>)

scala&gt; m1.<span class="fu">intersectWith</span>(m2)((m1v,m2v) =&gt; m2v)
res23: Map[Char,Int] = Map(b -&gt; <span class="dv">2000</span>, c -&gt; <span class="dv">3000</span>)

scala&gt; m1.<span class="fu">intersectWith</span>(m2)((m1v,m2v) =&gt; m1v)
res24: Map[Char,Int] = Map(b -&gt; <span class="dv">200</span>, c -&gt; <span class="dv">300</span>)</code></pre></div>
<h4 id="развлекаемся-с-string">Развлекаемся с String</h4>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"># сделать строку множественного числа(наивный способ)
scala&gt; <span class="st">&quot;Typeclass&quot;</span>.<span class="fu">plural</span>(<span class="dv">1</span>)
res26: String = Typeclass

scala&gt; <span class="st">&quot;Typeclass&quot;</span>.<span class="fu">plural</span>(<span class="dv">2</span>)
res27: String = Typeclasss

scala&gt; <span class="st">&quot;Day&quot;</span>.<span class="fu">plural</span>(<span class="dv">2</span>)
res28: String = Days

scala&gt; <span class="st">&quot;Weekly&quot;</span>.<span class="fu">plural</span>(<span class="dv">2</span>)
res29: String = Weeklies

# безопасный парсинг значений типов Boolean, Byte, Short, Long, Float, Double и Int
scala&gt; <span class="st">&quot;10&quot;</span>.<span class="fu">parseDouble</span>
res30: scalaz.<span class="fu">Validation</span>[NumberFormatException,Double] = <span class="fu">Success</span>(<span class="fl">10.0</span>)

scala&gt; <span class="st">&quot;ten&quot;</span>.<span class="fu">parseDouble</span>
res31: scalaz.<span class="fu">Validation</span>[NumberFormatException,Double] = <span class="fu">Failure</span>(java.<span class="fu">lang</span>.<span class="fu">NumberFormatException</span>: For input string: <span class="st">&quot;ten&quot;</span>)</code></pre></div>
<h3 id="заключение">Заключение</h3>
<p>Я надеюсь, что вам понравилось это краткое введение в Scalaz. И как вы уже видели эти простые функции уже позволяют делать множество интересных вещей, без необходимости разбираться с внутренними сложностями Scalaz. Паттерн рассматриваемый здесь называется TypeClass Pattern и используется для расширения стандартной функциональности типов в Scala.</p>
<p>В следующей статье мы познакомимся с более сложными вещами и поработаем с монадными трансформерами.</p>
<p><a href="http://www.smartjava.org/content/scalaz-features-everyday-usage-part-1-typeclasses-and-scala-extensions">Оригинальная статья.</a></p>

  <div id="socialButtons">
    <script type="text/javascript" src="//yastatic.net/es5-shims/0.0.2/es5-shims.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="//yastatic.net/share2/share.js" charset="utf-8"></script>
    <div class="ya-share2" data-services="vkontakte,facebook,linkedin,gplus,twitter,blogger,reddit,evernote,lj,pocket" data-counter=""></div>
  </div>

  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'beizeroblog'; // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
]]></summary>
</entry>
<entry>
    <title>"Hello, World!" на Scala под Android</title>
    <link href="/posts/2016-03-09-helloworld-on-android-with-scala.html" />
    <id>/posts/2016-03-09-helloworld-on-android-with-scala.html</id>
    <published>2016-03-09T00:00:00Z</published>
    <updated>2016-03-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="blog-post">
  <h2 class="blog-post-title">
    "Hello, World!" на Scala под Android
  </h2>
  <p class="blog-post-meta">
    <span class="date">2016-03-09</span> - <span class="tags"><a href="/tags/scala.html">scala</a>, <a href="/tags/android.html">android</a>, <a href="/tags/scaloid.html">scaloid</a></span>
  <p>В данной статье я постараюсь рассказать о том как начать разрабатывать приложения под Android используя Scala и SBT. Предполагается что у вас уже установлены Android SDK и SBT. <!--more--> Первое что нам нужно сделать это указать переменную окружения ANDROID_HOME. На OS X с Android SDK установленным через Homebrew для этого нужно выполнить команду:</p>
<pre class="shellsession"><code>export ANDROID_HOME=/usr/local/Cellar/android-sdk/{sdk-version}</code></pre>
<p>Не забудьте запустить Android SDK Manager и установить все нужные вам пакеты. Для сборки проекта мы будем использовать SBT(в данный момент у меня стоит версия 0.13.11) с плагином android-sdk-plugin. В директории будущего проекта создадим файл</p>
<pre><code>/project/plugins.sbt</code></pre>
<p>со следующим содержимым</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">addSbtPlugin</span>(<span class="st">&quot;com.hanhuy.sbt&quot;</span> % <span class="st">&quot;android-sdk-plugin&quot;</span> % <span class="st">&quot;1.5.19&quot;</span>)</code></pre></div>
<p>запустим sbt из директории с проектом и выполним следующую команду</p>
<pre><code>gen-android android-23 org.my_company project_name</code></pre>
<p>первый аргумент здесь platform-target(23 соответствует версии Android 6.0 Marshmallow), второй package-name, третий project-name, а так же укажем в build.sbt версию Scala(нам понадобится версия 2.11.5 или новее) добавив строку</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">scalaVersion := <span class="st">&quot;2.11.8&quot;</span></code></pre></div>
<p>После этого мы уже можем собрать наш проект и посмотреть что же получилось командой</p>
<pre><code>sbt android:package</code></pre>
<p>К сожалению иногда proguard не запускается, возможно из-за отсутствия “существенных” изменений в проекте, и когда вы набираете достаточное количество кода и зависимостей в своём проекте компилятор начинает иногда выдавать ошибку вида</p>
<pre><code>trouble writing output: Too many method references: 94505; max is 65536.</code></pre>
<p>один из вариантов решения проблемы это запускать сборку проекта предварительно его “очистив”</p>
<pre><code>sbt clean &amp;&amp; sbt android:package</code></pre>
<p>Самое время сделать наш код немного лучше. Откроем файл</p>
<pre><code>/src/main/scala/org/my_company/sample.scala</code></pre>
<p>тем кто уже знаком с разработкой под Android на Java данный код будет более чем знаком и в этом заключается основаная проблема — стандартная библиотека Android не предназначена для написания программ на Scala и код остаётся всё таким же громоздким, но к счастью есть замечательная библиотека scaloid! Добавим эту библиотеку в зависимости к нашему проекту и в исключения к proguard(странно, но без этого компиляция фейлится), для этого в build.sbt добавим следующие строчки</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">libraryDependencies += <span class="st">&quot;org.scaloid&quot;</span> %% <span class="st">&quot;scaloid&quot;</span> % <span class="st">&quot;4.2&quot;</span>

proguardOptions in Android ++= Seq(<span class="st">&quot;-dontwarn org.scaloid.**&quot;</span>)</code></pre></div>
<p>теперь перепишем наш файл sample.scala используя scaloid</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> org.<span class="fu">my_company</span>

<span class="kw">import</span> org.<span class="fu">scaloid</span>.<span class="fu">common</span>.<span class="fu">_</span>

<span class="kw">class</span> MainActivity <span class="kw">extends</span> SActivity {

   onCreate {

      contentView = <span class="kw">new</span> SVerticalLayout {

         <span class="fu">SButton</span>(<span class="st">&quot;Say Hello&quot;</span>, <span class="fu">toast</span>(<span class="st">&quot;Hello, World!&quot;</span>))

      }

   }

}</code></pre></div>
<p>На этом всё, можем собрать наш проект, запустить, нажать кнопку “Say Hello” и увидим заветные два слова.</p>

  <div id="socialButtons">
    <script type="text/javascript" src="//yastatic.net/es5-shims/0.0.2/es5-shims.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="//yastatic.net/share2/share.js" charset="utf-8"></script>
    <div class="ya-share2" data-services="vkontakte,facebook,linkedin,gplus,twitter,blogger,reddit,evernote,lj,pocket" data-counter=""></div>
  </div>

  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'beizeroblog'; // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
]]></summary>
</entry>

</feed>
